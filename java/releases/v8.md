# v8

Java 8 is a major improvement from v7. It included a lot of features to cope with other programming languages. It's a step towards functional programming and introduces _<mark style="background-color:blue;">Functions</mark>_ as first-class citizens in Java. The focus has been really on reducing the boilerplate code to write the stuff.

Major features include:

Functions (Lambda Expressions)

Method References

Streams API

Optional Class

Date/Time API

### Functions or Lambda Expressions:

Before v8 we could not pass a method as a reference it had to be either a primitive value or object reference. Now methods are first-class citizens and we can pass methods as reference values.

A _**Function or Lambda**_ is different from a _**Method.**_ A method is typically associated with a class, but the function is anonymous, has no name, and is not associated with any class similar to the method it can accept parameters, have a return type, and throw errors.

A Functional interface is an interface with a single method. We have already seen a lot of functional interfaces before like `Runnable`

```java
interface Runnable {
    public void run();
}

Runnable r = new Runnable() {
    public void run() {
        System.out.println("Hello World!")
    }
}
```

With lambda, we can write the shorthand notion:

```java
Runnable r = () -> System.out.println("Hello World"); // This is a function
```

> A Lamda is simply a shorthand notation of an anonymous class with a single method in it. It is a clear and concise way to represent a method inside a functional interface using an expression&#x20;

Valid forms of lambda expressions are:

```java
// returns void
() -> {}
// Single line
() -> System.out.print("Hello World");
// Multiline
() -> {
    System.out.println("Hello World");
    return 10;
}
```

#### Function descriptor:

The signature of the abstract method of the functional interface describes the signature of the lambda expressions. We call this as `Function descriptor`

For example: `() -> void` can be associated with any functional interface that returns `void` It can be a Runnable interface.

| Functional Interface  | Function Descriptor | Abstract Method |
| --------------------- | ------------------- | --------------- |
| `Predicate<T>`        | `T -> boolean`      | `test`          |
| `Consumer<T>`         | `T -> void`         | `accept`        |
| `Function<T, R>`      | `T -> R`            | `apply`         |
| `Supplier<T>`         | `() -> T`           | `get`           |
| `BiFunction<T, R, V>` | `(T, R) -> V`       | `apply`         |
| `UnaryOperator<T>`    | `T -> T`            | `identity`      |
| `BinaryOperator<T>`   | `(T, T) -> T`       | `apply`         |
| `BiConsumer<T, R>`    | `(T, R) -> void`    | `accept`        |

`UnaryOperator, BinaryOperator` are special kind of `Function` with only a single `type`

> In java, there is a cost to `boxing` and `unboxing`as boxed values ise more memory and require addtional memory lookups to fetch the wrapped primitive values

```java
Predicate<Integer> checkForEven = (a) -> a % 2 == 0;
checkForEven.test(1000); // Boxes the value 1000 to an integer object

IntPredicate<Integer> checkForOdd = (a) -> a % 2 != 0;
checkForOdd.test(1001); // Value is not boxed
```

Java provides `Int, Double, Long and Boolean` functional interfaces to avoid boxing and unboxing, so when necessary use them to increase performance.

#### Method References:

Java allows to pass methods inside the class as lambdas if they match the function descriptor

There are three ways a method can be used as lambda (Method reference)

1. A method reference to a static method inside a class.

```java
(args) -> ClassName.staticMethod(args);
// ClassName::staticMethod
```

2. A method reference to an instance method of an arbitrary object of a particular type

```java
(obj, args) -> obj.instanceMethod(args);
// ClassName::instanceMethod (`obj` className)
```

3. A method reference to a local instance variable method used inside lambda

```java
(args) -> expr.instanceMethod(args);
// expr::instanceMethod
```

{% code overflow="wrap" lineNumbers="true" fullWidth="false" %}
```java
class Person {
    int age;
    String name;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }

    // static method accessed as Person.compareByName
    public static int compareByName(Person p1, Person p2) {
        return p1.getName().compareTo(p2.getName());
    }
    // static method accessed as Person.compareByAge
    public static int compareByAge(Person p1, Person p2) {
        return p1.getAge() - p2.getAge();
    }
}

class PersonUtils {
    public int getLengthOfPerson(Person p) {
        return p.getName().length();
    }
}

public class TestMethodReferences {
    // Sort People By Name
    public static void staticMethodReference(List<Person> people) {
        // Before Java 8
        Collections.sort(people, new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getName().compareTo(o2.getName());
            }
        });

        // Using lambda
        Collections.sort(people, (p1, p2) -> p1.getName().compareTo(p2.getName()));

        // Using static method on the the class
        Collections.sort(people, (p1, p2) -> Person.compareByName(p1, p2));
        
        // Using method reference, here arguments received by lambda are passed into the static method
        Collections.sort(people, Person::compareByName);
    }
    
    // Get the names of all people
    public static void objectTypeInstanceMethodReference(List<Person> people) {
        // Using lambda
        people.stream().map((p) -> p.getName());
        
        // Using method reference on the object type in lambda expression
        people.stream().map(Person::getName);
    }
    
    // Get names by local variable reference
    public static void localVariableInstanceMethodReference(List<Person> people) {
        PersonUtils personUtils = new PersonUtils();
        
        // Using lambda
        people.stream().map((p) -> personUtils.getLengthOfPerson(p));
        
        // Using local variable instance method reference
        people.stream().map(personUtils::getLengthOfPerson);
    }
}

```
{% endcode %}
